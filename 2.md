# einsum_summary
对爱因斯坦求和约定的个人备忘录

爱因斯坦求和约定其实就是两个矩阵之间各个元素的相乘和相加运算，还涉及到的像素操作包括元素的重复使用。  
至于  
1、元素的重复使用次数  
2、相乘后的相加策略  
均需要通过torch.einsum输入的参数进行确定。  

以四阶矩阵进行举例，设A为“hijk”，B为“jklm”，希望得到的矩阵C为“hjm”，即  
C = torch.einsum("hijk", "jklm"->"hjm", A, B)  
具体怎么实现呢？  

1、"hijk", "jklm" -> "hi"×"jk", "jk"×"lm"  
首先将A、B进行比较，寻找共同维度以及不同维度；  
即A、B相同维度包括j、k，不同维度A包括h、i,B包括l、m。  
然后将A、B进行降维，以维度是否相同进行分类，A降为"hi"和”jk“,B降为"lm"和"jk"。  
那么为什么"hi"作为两个维度，可以化为一个维度呢？  
画个图可以意会：  
![降维示意图](/img/2-0.jpg)    
由此，可将A、B的爱因斯坦求和简化为两个二维矩阵的相乘。  

1.5、二维矩阵相乘的画图理解  
两个二维矩阵的相乘需要前提条件，即前一矩阵的列数应等于后一矩阵的行数。  
而对于爱因斯坦求和的两个矩阵，如A、B，相同维度为"jk"，不同的为"hi"与"lm"。  
不妨把两个矩阵想象为两个卷珠帘，如下图所示：  
![A与B](/img/2-1.jpg)  

矩阵相乘结果是一个拥有更多珠的卷珠帘，如下图所示：  
![A与B相乘结果，其实一眼就看出它跟AB的关系有木有！](/img/2-1-1.jpg)  

相乘结果的每一串都是由A、B对应的每一串运算得到，实际上就是由颜色相同的珠子对应值相乘得到。 
那么实际操作过程是如何实现的呢？  

2、"hi"×"jk", "jk"×"lm" -> "hi"×"jk"×"lm"（这一步只包含元素间的相乘操作）  
首先将A的第一串，分别与B的每一串，进行运算，颜色相同的输入进行相乘，结果存到相同颜色的输出中；  
运算过程如下图所示：  
![第一步](/img/2-2.jpg) ![第一步结果](/img/2-2-1.jpg)  

再将A的第二串，与B的每一串进行运算；  
运算过程如下图所示：  
![第二步](/img/2-3.jpg) ![第二步结果](/img/2-3-1.jpg)  

以此类推，直至A的每一串均进行了运算。  
运算过程如下图所示：  
![第n步](/img/2-4.jpg) ![第n步结果](/img/2-4-1.jpg)  
![第n+1步](/img/2-5.jpg) ![第n+1步结果](/img/2-5-1.jpg)  

此时，得到的结果矩阵的维度可视为"hi"×"jk"×"lm"。    
![前后为"hi"，上下为"jk"，左右为"lm"](/img/2-1-1.jpg)  
我们得到了简化后矩阵相乘的结果，如何得到最终的结果呢？  

3、"hi"×"jk"×"lm" -> "hijklm" -> "hjm"（这一步只包含元素间的相加操作）    
将简化的矩阵相乘结果进行维度展开，即将三维矩阵转换至六维矩阵，完成"hi"×"jk"×"lm" -> "hijklm"。  
然后对维度进行压缩，也就是将不存在的维度"ikl"上的元素进行相加。  
（并不是说压缩后该维度就消失了，只是它变成了长度为1的维度！）  
鉴于六位矩阵太难用示意图表示了(╯‵□′)╯︵┻━┻，以三维矩阵表示一下压缩过程。  
压缩过程如下图所示：  
![压缩前](/img/2-1.jpg) ![压缩后](/img/2-6.jpg)    
珠子都被压到一块了，进行的操作实际上就是相加啦。  
由此，完成了"hijklm" -> "hjm"  

The End！

